---
sidebar_position: 2
---

# 1장. 깨끗한 코드

<br/>

## 들어가며

---

이 책을 읽는 이유가 있다면 다음 두 가지 중 하나일 것이다.

- 프로그래머라서,
- 더 나은 프로그래머가 되려고,

이 책은 코드에 대해 아주 자세히 다룰 것이며, 그렇기에 읽고 나면 **어떤 코드가 좋은 코드고 나쁜 코드인지 구분하는 능력과 좋은 코드를 작성하는 능력, 나쁜 코드를 좋은 코드로 바꾸는 능력**들을 얻을 것이다.

<br/>

## 코드가 존재하리라

---

코드가 사라질 수도 있다는 사람들로 하여금(그들은 모델이나 요구사항에 집중해야 한다고 생각) 해당 서적은 시대에 뒤떨어지는 주제라고 생각할 수 있다.

- 하지만 코드는 **요구사항을 상세히 표현하는 수단**이기에 사라질 수 없다.
  - 코드의 도움 없이는 불가능하고, **추상화**도 불가능하다.
- 사람들은 요구사항을 모호하게 제시해도 의도를 정확히 꿰뚫는 기계를 원한다.
  - 하지만 이는 불가능한 기대고, 인간 또한 고객의 막연한 감정만으로는 성공적인 시스템을 구현하지 못한다.

궁극적으로 **코드는 요구사항을 표현하는 언어**라는 사실을 명심한다.

- 요구사항에 더 가까운 언어를 만드는 것이나, 요구사항에서 정형 구조를 뽑아내는 도구를 만들 수도 있다.
  - 하지만, 어느 순간에는 **정밀한 표현**이 필요하다.
  - 그 필요를 없앨 이유 또한 없기에, **코드는 사라지지 않으리라.**

<br/>

## 나쁜 코드

---

나쁜 코드를 이야기하기 전에 **좋은 코드가 중요한 이유**를 알아보기 위한 일화를 들어보자.

> 80년대 초, 킬러앱을 만든 어느 한 회사는 출시 이후, 제품 출시 간격이 계속 늘어지기 시작하더니 버그가 버전을 넘어서면서도 계속 잔존하는 문제가 생겼다. 이후 프로그램 시동 시간과 죽는 횟수도 늘어나며 이를 사용하지 않게 되었다. 이후 회사가 망하고 20년이 지난 뒤, 초창기 직원을 만나 자초지종을 들어보니 출시에 바빠 코드를 마구잡이로 짰고, 결론적으로 **나쁜 코드가 회사를 망하게 했다.**

나쁜 코드를 작성하여 고생한 경험은 다들 하나씩 있을 것이고 이를 **고행**이라고도 한다.

- 온갖 핑계를 대며 미뤄둔 코드는 정상적으로 작동한다는 사실에 스스로를 위로하게 되고 나중에 손보겠다고 했던 생각은 점점 사라져 결국, **나중은 오지 않게 된다.**

<br/>

## 나쁜 코드로 치르는 대가

---

2-3년 넘게 프로그램을 짰다면, 내 코드가 아닌 남들이 저질러놓은 나쁜 코드로 고생한 경험이 있을 것이다. 또한, 이를 통해 프로젝트 진도가 안나가는 것도 경험했을 것이다.

- **나쁜 코드는 개발 속도를 크게 떨어뜨린다.**
  - 나쁜 코드를 통해 팀 생산성이 떨어지고, 그러다 **생산성이 0에 수렴하는 순간**이 온다.
  - 관리층은 이를 복구하기 위해, **새로운 인력을 투입**시킨다.
  - 새로운 인력은 기존 시스템에 대한 이해가 깊지 않기에, **설계 의도 혹은 이에 반하는 변경을 구분하지 못한다.**
  - 새로운 인력은 팀 생산성 증가에 대한 압력에 시달리고, **결국 나쁜 코드를 양산한다.**

<br/>

### 원대한 재설계의 꿈

---

한계에 다다른 팀원들은 재설계를 관리층에게 요구하고, 달갑지는 않지만 생산성의 상황을 알기에 이를 승인한다. 그리고 새로운 재설계를 위한 타이거팀이 생긴다.

- 타이거팀은 **기존 서비스의 기능을 모두 제공**하며, 그동안 **기존 시스템에 가해지는 변경도 모두 따라잡아야 한다.**
  - 기존 시스템의 기능을 제공하지 않는다면, 관리층은 기존 시스템을 대체하지 않기 때문이다.
- 그렇게 진행되는 재설계는 길면 10년까지 이어지고, 초창기 타이거 팀원들은 모두 팀을 떠났으며, 새로운 팀원들이 새로운 서비스를 설계하자고 한다.

이를 통해, 시간을 들여 **깨끗한 코드를 만드는 노력**이 **비용을 절감**하고 이러한 방식이 **전문가로서 살아남는 방식**임을 알게 된다.

<br/>

### 태도

---

나쁜 코드로 구성된 프로그램의 원인에서 **프로그래머를 제외하는 것은 어렵다.**

- 관리자와 마케팅 팀원들은 우리에게 정보와 현실성을 요구하며, 이를 요구하지 않아도 제공해야 마땅하다.
- 프로젝트 관리자는 일정을 잡으며 우리에게 도움을 요청한다.

그렇기에 우리에게도 커다란 책임이 있다. 나쁜 코드가 초래하는 실패에는 더더욱 책임이 크다.

> "아니 잠깐만요! 상사가 시키는 대로 하지 않으면 짤린다구요!"

그들이 일정과 요구사항을 강력하게 밀어붙이는 이유는 그것이 그들의 책임이기에 그런 것이고, **좋은 코드를 사수하는 일**은 바로 우리 **프로그래머들의 책임**이다.

<br/>

### 원초적 난제

---

대부분의 프로그래머들이 나쁜 코드가 업무 속도를 늦춘다는 사실을 익히 알지만, 기한을 맞추기 위해 나쁜 코드를 양산할 수 밖에 없다고 느낀다.

- 하지만 전문가들은 나쁜 코드를 양산하는 것이 기한을 맞추지 못하게 하며, 이를 맞추는 유일한 방법은 **언제나 코드를 최대한 깨끗하게 유지하는 습관**이라는 것을 안다.

<br/>

### 깨끗한 코드라는 예술?

---

나쁜 코드가 심각한 장애물이라는 사실을 알았다고 가정해도, 깨끗한 코드가 무엇인지 모르면 이는 소용이 없는 짓이다.

- 깨끗한 코드를 작성하는 것은 **그림을 그리는 것**과 같다.
- 그렇지만, 잘 그린 그림을 구분하는 능력과 잘 그리는 능력과는 다른 것처럼 **깨끗한 코드를 작성하는 것은 다른 맥락이다.**
- 깨끗한 코드를 작성하는 것은 열쇠는 **'코드 감각'**이며, 코드 감각이 있으면 **좋은 코드와 나쁜 코드를 구분**하고 **좋은 코드로 바꾸는 전략도 파악**한다.

다시 말해, 깨끗한 코드를 작성하는 것은 빈 캔버스를 우아한 작품으로 바꾸는 것과 같다.

<br/>

### 깨끗한 코드란?

---

프로그래머의 수만큼 해당 정의는 다양할 것이다. 필자 주변의 유명하고 노련한 프로그래머들에게 의견을 물었다.

<br/>

#### 비야네 스트롭스트룹

---

- **우아하고 효율적인** 코드
- 버그 방지를 위해 논리를 간단하게 하고, 유지보수를 위해 의존성을 최대한 줄여라.
- **오류는 명백한 전략에 의거해 철저히 처리한다.**
- 성능을 최적으로 유지하는 것이, 사람들이 코드를 망치려는 **유혹**을 떨치는 방법이다.

비야네에게 우아한 코드는 아마 **보기에 즐거운 코드**일 것이다. 또한, 효율은 단순히 속도만을 의미하는 것은 아닐 것이다. CPU 자원을 낭비하는 코드도 우아하지 못하다.

**철저한 오류 처리**는 세세한 사항까지 꼼꼼히 신경쓰라는 말이다. 프로그래머들이 대충 넘어가는 오류 처리들로는 **메모리 누수, 경쟁 상태, 일관성 없는 명명법** 등이 있다.

마지막으로, 깨끗한 코드는 **한 가지를 잘한다.** 수많은 소프트웨어 설계 원칙이 이 간단한 교훈 하나로 귀결된다는 사실은 우연이 아니다.

#### +a) 데이브 토마스와 앤디 헌트

- 창문이 깨진 건물(나쁜 코드)은 아무도 신경 안쓰며, 더 깨져도 신경쓰지 않는다.
- 이후, 낙서를 방치하고 쓰레기가 쌓이며 결국 쇠퇴하는 과정이 시작된다.

<br/>

#### 그래디 부치

---

- 깨끗한 코드는 단순하고 직접적이며, 잘 쓴 문장처럼 읽힌다.
- 깨끗한 코드는 결코 설계자의 의도를 숨기지 않으며, 오히려 **명쾌한 추상화**와 **단순한 제어문**으로 가득하다.

그래디는 **가독성**을 강조한다. 마치 잘 쓴 문학 소설을 읽은 것처럼 **물 흐르듯이 읽히는 코드야 말로 깨끗한 코드**가 아닌가.

**명쾌한 추상화**란 참으로 재미난 모순어법이다. 이는 코드가 **추측이 아닌 사실에 기반해야 한다는 점을 의미한다**고 볼 수 있다.

<br/>

#### 큰 데이브 토마스

---

- 깨끗한 코드는 **작성자가 아닌 사람도 읽기 쉽고 고치기 쉽다.**
- 또한, **단위 테스트 케이스와 인수 테스트 케이스가 존재**한다.
- 깨끗한 코드에는 의미있는 이름이 붙으며, 특정 목적을 달성하는 방법은 하나 뿐이다.
- 의존성은 **최소**이며, 각 의존성을 명확히 정의한다.
- 코드는 **문학적으로 표현해야 마땅하다.**

큰 형님 데이브는 깨끗한 코드가 **다른 사람이 고치기 쉽다**고 단언한다. 실제로 읽기 쉬운 코드와 고치기 쉬운 코드는 엄연히 다르다.

테스트 주도 개발(TDD)이 근본적인 원칙 중 하나가 되었고, **테스트 코드가 없는 코드는 깨끗한 코드가 아니다.**

또한, **최소**라는 단어에서 큰 코드보다 작은 코드에 가치를 둔다는 것과 **문학적**이라는 점에서 사람이 읽기 좋은 코드를 작성하라는 뜻을 알 수 있다.

<br/>

#### 마이클 페더스

---

- 깨끗한 코드의 특징은 많지만, 그 중에서도 모두를 아우르는 특징은 깨끗한 코드가 **언제나 누군가 주의 깊게 짰다는 느낌을 준다는 것**이다.
  - 고치려고 해도 딱히 손 댈 곳이 없으며, 고칠 궁리를 하다보면 언제나 제자리로 돌아오게 된다.

깨끗한 코드란 시간을 들여 깔끔하고 단정하게 정리한 코드이며, **주의를 기울인 코드**이다.

<br/>

#### 론 제프리스

---

최근 론은 켄트 벡이 제안한 단순한 코드 규칙으로 구현을 시작한다고 한다. 이는 다음과 같다.

- 모든 테스트를 통과한다.
- 중복이 없다.
- 시스템 내 모든 설계 아이디어를 표현한다.
- 클래스, 메서드, 함수 등을 최대한 줄인다.

론은 주로 **중복**에 집중한다고 한다. 같은 작업을 여러 차례 반복한다면 코드가 아이디어를 제대로 표현하지 못한다는 증거다. 그렇기에 문제의 아이디어를 찾아 좀 더 **명확하게 표현하려 애쓴다.**

표현력은 **의미 있는 이름**을 포함한다. 하지만 표현력은 이름에만 국한되지 않는다. 여러 기능을 수행하는 객체나 메서드를 찾기도 한다. 중복과 표현력을 개선하기만 해도 코드가 크게 나아진다.

이 외에 중요한 부분은 **집합에서 항목 찾기**와 관련된 내용이 있다. 데이터베이스와 같은 집합에서 특정 항목을 찾는 경우가 자주 발생한다. 이럴 때마다 **추상 메서드나 추상 클래스를 만들어 실제 구현을 감싼다.** 다른 코드는 추상 클래스나 추상 메서드가 제공하는 기능을 사용하므로, 재빨리 간단하게 구현했다가 나중에 필요할 때 바꾸면 된다. 게다가 집합을 추상화하면 **진짜 문제에 신경 쓸 여유가 생긴다.**

**중복 줄이기, 표현력 높이기, 초반부터 간단한 추상화 고려하기**, 이 세 가지가 론에게 가장 중요한 요소이다.

<br/>

#### 워드 커닝햄

---

<!--
TODO 인상 깊었던 부분 메모!
-->

> <p style={{color: 'gray'}}>이 부분은 문장이 너무 마음에 들어서 인용을 통해 별도로 작성합니다.</p>
>
> **코드를 읽으면서 짐작했던 기능을 각 루틴이 그대로 수행한다면 깨끗한 코드**라 불러도 되겠다. 코드가 그 문제를 풀기 위한 언어처럼 보인다면 아름다운 코드라 불러도 되겠다.

깨끗한 코드는 **읽으면서 놀랄 일이 없어야 한다**고 워드는 말한다. 코드를 독해하느라 머리를 쥐어짜지 않아야 된다는 말이다. 각 모듈은 다음 무대를 준비하고, 모듈을 읽으면 다음에 벌어질 일이 상상된다. 설계자가 코드를 어이 없을 정도로 단순하게 설계했기 때문이다.

게다가 워드가 말하는 **미(아름다움)**는 어떤가? 언어가 단순하게 보이도록 만드는 책임은 우리에게 있다고 말한다. 특정 언어를 신봉하는 광신도들이 많지만, 결국 중요한건 언어는 이에 대한 열쇠가 아니다.

<br/>

## 우리들 생각

---

그렇다면 이를 작성한 이들의 생각은 어떠한가? 이 책에서 설명하는 교훈은 필자가 경험한 바로 **절대적인 진리**이며 필자와 동료들의 입장에서 **깨끗한 코드**를 정의한다.

무술가들에게 각 무술별로 문파가 존재하고 최고 기술이란 다들 다르게 답하는 것처럼, 필자 못지 않은 **다양한 경험 많은 집단과 전문가가 존재**한다. 그렇기에 마땅히 그들에게서도 배우라고 권한다.

실제로 이 책에서 주장하는 기법 다수는 논쟁의 여지가 있으며, 모든 기법에 동의하지 못할 수도 있다. 그렇지만, 이는 수십 년에 걸친 경험과 반복적인 시행착오로 습득한 교훈과 기법이기에 존중하려 애써주면 좋겠다고 필자는 전한다.

<br/>

## 우리는 저자다

---

우리는 독자이기 이전에 **저자**라는 생각을 해야한다. 코드를 작성할 때, 우리의 노력을 보고 판단을 내릴 독자가 있다는 사실을 알아야한다.

실제로 코드에 들어가는 노력은 얼마나 들어갈까? 80년대 이맥스의 편집 세션 재생 기능은 사용자가 입력한 모든 키를 기억하고 이를 재생할 수 있다. 이에 대한 결과는 놀랍게도 **코드를 읽는 시간과 코드를 짜는 시간의 비율이 10대 1을 훌쩍 넘는다는 것**을 알 수 있다.

그렇기에 **기존 코드를 쉽게 읽는 것**은 중요한 문제이며, 새로운 코드를 구성하고자 할 때에도 이는 중요한 요인으로 작용한다. 서둘러 일을 마치려면 **쉽게 코드를 짜자.**

<br/>

## 보이스카우트 규칙

---

잘짠 코드가 전부는 아니며, **시간이 지나도 언제나 깨끗하게 유지해야 한다.** 우리는 적극적으로 코드의 퇴보를 막을 의무가 있는 것이다. 이를 위해 다음의 **보이스카우트 규칙**이 큰 도움이 될 것이다.

> 캠프장은 **처음 왔을 때보다 더 깨끗하게 해놓고 떠나라.**

체크아웃할 때, 더 깨끗한 코드를 체크인 한다면 코드는 절대 나빠지지 않는다. 변수 이름 하나를 개선하고, 조금 긴 함수를 분할하고, 약간의 중복을 제거하고, 복잡한 `if` 문 하나를 정리하면 충분하다.

시간이 지날수록 코드가 좋아지는 프로젝트에서 작업한다고 상상해보면, 전문가에겐 너무나도 당연한 것이다.

<br/>

## 프리퀄과 원칙

---

이 책은 많은 면에서 PPP 책의 프리퀄이다. 해당 서적은 객체 지향 설계의 원칙을 설명하고, 전문 개발자들이 사용하는 실무 기법을 소개한다.

이 책에서는 다양한 설계 원칙을 산발적으로 거론한다. **SRP(Single Responsibility Principle), OCP(Open Closed Principle), DIP(Dependency Inversion Principle)** 등이 그 예이다.

<br/>

## 결론

---

예술에 대한 책을 읽고 예술가가 된다는 보장이 없듯이 이 책 또한 그러하다. 단지 뛰어난 프로그래머가 사용하는 기술과 기교와 도구를 소개할 뿐이다.

이 책은 코드도 많고, 좋은 코드와 나쁜 코드를 둘 다 설명한다. 또한, 나쁜 코드를 좋은 코드로 바꾸는 방법도 설명하며 다양한 경험적 교훈과 체계와 절차와 기법도 열거한다. **나머지는 여러분에게 달려있다.**

> **"연습하라"**
